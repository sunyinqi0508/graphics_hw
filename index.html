<script src=lib2.js></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/ace.js"crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/ext-language_tools.js" crossorigin="anonymous"></script>
<style>
 .ace_gutter-layer {
   /* original width is 48px */
   width: 25px !important;
 }
 
 .ace_gutter-layer > * {
   /* 48 - 32 = 16 */
   margin-left: 0;
 }
 .ace_gutter-cell {
  padding-left: 0 !important;
  padding-right: 3px !important;
 }
 .code{ 
    font-family: "monaco, menlo, ubuntu mono, consolas, source-code-pro" ;
    }
 </style>
<body bgcolor=white text=black link=black alink=blue vlink=blue>
<center>
<canvas id='canvas1' style="width: 600px; height:600px;" width=1200 height=1200></canvas>
</center>
</body>


<!!-------- VERTEX SHADER: YOU PROBABLY DON'T WANT TO CHANGE THIS RIGHT NOW -------->

<script id='my_vertex_shader' type='x-shader/x-vertex'>
   attribute vec3 aPos;
   varying   vec3 vPos;
   void main() {
      gl_Position = vec4(aPos, 1.);
      vPos = aPos;
   }
</script>


<!!-------- FRAGMENT SHADER: THIS IS WHERE YOU WILL DO YOUR WORK -------->
<!!-------- FRAGMENT SHADER: MOVED TO ./shader.frag LOADED IN lib2.js -------->
<!--script src="shader.frag" id='my_fragment_shader' type='x-shader/x-fragment'> </script>


<!!-------- CREATE A PROPERLY DESCRIPTIVE TITLE BELOW -------->

<script id='my_title' type='text/html'>
Solar RTX
</script>


<!!-------- HERE IS WHERE YOU CAN PROVIDE A LONGER TEXT DESCRIPTION -------->

<script id='my_instructions' type='text/html'><font color=#909090>
<p style="font-size:30px; ">In this homework, I implemented Global illumination w/ 
   Realtime Recursive Ray Tracing! 
<p>
<i style="font-size:25px;">Here is how it works:</i>
<ul>
   <li>First, I started with what I've already done in homework 1. Which already included complete Phong shading with 
      Specular light and much more (spherical texture mapping, simple interactions, improved UI/shader editor).
   </li>
   <li> I then merged the code from hw2 and added texture to each sphere.</li>
   <li> I modified the ray tracing algorithm so that when hitting an object, instead of returning color calculated from 
      Phong model:<br>
      <ul>
         <li>I recursively traced the light reflected and refract from the object.</li>
         <li></li>
      </ul>
   <li></li>   
   <li>Finally, I used super sampling via doubling the render dimensions of the canvas to reduce aliasing.</li>
   <li>Repo on <a href="https://github.com/sunyinqi0508/graphics_hw1">Github</a>.</li>
   </li>
 </ul>
<p>

</script>


<!!-------- YOU PROBABLY WANT TO CHANGE ANYTHING BELOW RIGHT NOW -------->
   
<script>

// CREATE THE HTML DOCUMENT
let flags = 0x0;
let vs = my_vertex_shader.innerHTML;
    //* LOADING FRAGMENT SHADER
    var client = new XMLHttpRequest();
    client.open('GET', './shader.frag');
    client.onloadend = function() {
      fs = (client.responseText);
      //* START EVERYTHING AFTER FRAGMENT SHADER IS DOWNLOADED.
      gl_start(canvas1, vs, fs);
      editor.getSession().setValue(fs);
      editor.session.on('change', function(delta) {
         if(typeof canvas1.setShaders === "function")
         {
            canvas1.setShaders(vs, editor.getSession().getValue());
            setUniform('1i', 'flags', flags);
         }
      });
    }
   client.send();
document.body.innerHTML = [''
   ,'<font size=7 color=#909090>' + my_title.innerHTML
   ,'<TABLE cellspacing=0 cellpadding=0><TR>'
   ,'<td><font color=red size=5><div id=errorMessage></div></font></td>'
   ,'</TR><TR>'
   ,'<table cellspacing=0>'
   ,'<tr>'
   ,'<td valign=top>'
   ,'<div id="ace" style="width:800px;height:1780px;"></div>'
   ,'</td><td valign=top>' + document.body.innerHTML  + '<div style=\'font-size:25px\'>' + my_instructions.innerHTML + '</div>' + '</td>'
   ,'</tr></table>'
   ,'</TR></TABLE>'
   ].join('');

// SET UP THE EDITABLE TEXT AREA ON THE LEFT SIDE.
ace.require("ace/ext/language_tools");
var editor = ace.edit("ace", {
   mode:"ace/mode/glsl",
   theme:"ace/theme/crimson_editor"
});
editor.setOptions({
   enableBasicAutocompletion: true,
   enableSnippets: true,
   enableLiveAutocompletion: true,
   fontSize: 14,
   fontFamily: "monaco, menlo, ubuntu mono, consolas, source-code-pro",
   fixedWidthGutter: true,
   showGutter: true,
   showPrintMargin: false,
});
editor.setAutoScrollEditorIntoView(true);
// REPARSE THE SHADER PROGRAM AFTER EVERY KEYSTROKE.
delete editor.KeyBinding;
let lastTime = Date.now();
let animating = true;
let ctrl = false;
canvas1.addEventListener('click',function(ev){
   if(animating)
      lastTime = Date.now();
   else
      startTime += Date.now() - lastTime;   
   animating = !animating;
});
document.addEventListener('keydown',(e)=>{
   if(e.code.startsWith('Control'))
   {
      ctrl = true;
   }
   else if(ctrl && e.code == 'KeyT')
   {
      mask = 0x1;
      flags = flags&!mask | (!(flags&mask)?mask:0);
      setUniform('1i', 'flags', flags);
   }
   else if (ctrl && e.code == 'KeyS')
   {
      let a = document.createElement('a');
      a.href = "data:text/plain,"+encodeURIComponent(editor.getSession().getValue());
      a.download = 'shader.frag';
      a.click();
   }
});

document.addEventListener('keyup',(e)=>{
   if(e.code.startsWith('Control'))
   {
      ctrl = false;
   }
});
// SET THE CURRENT TIME IN SECONDS BEFORE RENDERING EACH FRAME.

let startTime = Date.now();

function animate(gl) {
   if(animating)
      setUniform('1f', 'uTime', (Date.now() - startTime) / 1000);
   else
      setUniform('1f', 'uTime', (lastTime - startTime) / 1000);

}


</script>

